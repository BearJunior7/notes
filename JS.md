###NaN的类型归类

> NaN是一个独立的标识符，它的类型是number![image-20230927184439256](JS笔记.assets/image-20230927184439256.png)

### 类型转换

> undefined数字运算隐式转换不会转为0，null会转为0，在下图中把undefined赋值给x，再输出x的前自增，会输出NaN，而将null赋值给x，输出x的前自增则会默认将null隐式转换为0进行前自增，从而得到结果为0![image-20230928105748802](JS笔记.assets/image-20230928105748802.png)
>
> NaN和任何值做任何对比都是false，NaN和它本身也不相等==![image-20230928111111186](JS笔记.assets/image-20230928111111186.png)
>
> ”双等号“会有隐式转换的问题，尽量用“ === ”做对比判断，双等号性能差![image-20230928112522024](JS笔记.assets/image-20230928112522024.png)
>
> 不能用数学思维来思考，null和undefined双等是true，不代表null就大于等于undefined![image-20230928143636454](JS笔记.assets/image-20230928143636454.png)
>
> `  console.log(null>=0); `结果为true
>
> ` console.log(undefined>=0);`结果为false
>
> 在进行对比时，null可以转换为0，而undefined不能转换为0

### 对象和对象永远不相等

> 一个对象是开辟出一个地址空间存储的，比较两个对象相当于是比较两个地址，没有意义![image-20230930092441151](JS笔记.assets/image-20230930092441151.png)

### 数组做数学运算判读引擎

> + 用-[-1,]可以判断是否是主流引擎，如果是主流引擎，后面那项为空则会直接去掉；如果在IE678下则不会这么做，会将其补上undefined，变为-[-1,undefined]
>
>   + -[-1]可以转换为数字1，对其取反可以得到false，而-[-1,undefined]对其做数学运算可以得到NaN，对NaN取反则可以得到true，也可以根据这个来判断浏览器引擎![image-20230930093017024](JS笔记.assets/image-20230930093017024.png)
>   + 如果数组里面只有一项，且里面的这一项可以转换为数字，则这个数组是可以进行数字运算的，如果不止一项，则做数字运算会变为NaN
>
> + 数组和字符串的亲和力是非常高的，有加号连接的情况会尽可能转换为字符串
>
>   ![image-20230930094240369](JS笔记.assets/image-20230930094240369.png)

### for循环数组遍历优良写法

> 在for循环初始化变量时，定义一个变量等于数组的长度，这样的话当循环执行的时候只会计算一次数组的长度，如果直接写成
>
> ```
> for(var i = 0,i<arr.length;i++) {
> 
> }
> ```
>
> 则每当循环执行一次，就会调用一遍数组的长度，增加了代码的时间复杂度![image-20230930100117075](JS笔记.assets/image-20230930100117075.png)

### 浅拷贝——slice()方法/push()/concat()

> 1. 可以用数组中的slice()方法来实现浅拷贝，slice()是切割一个数组并返回新的数组 ，不传参数就相当于是全切割，相当于是重新把原数组的值赋值给变量，而不是传址，此时再改变newArr的值，plants中的值不再发生变化。
>
>    ![image-20231001092055640](JS笔记.assets/image-20231001092055640.png)
>
> 2. 还可以用下面的方法来切断newArr与plants之间的引用，实现浅拷贝。下面用一个for循环，一个一个取出plants中的值，再利用push()方法将其一个一个添加给newArr，这样也能达到切断引用的目的。
>
>    ![image-20231001092554530](JS笔记.assets/image-20231001092554530.png)
>
> 3. 可以用concat()方法实现浅拷贝，同样不传参数，这样调用concat()方法就不会往原数组里增加新的值，并且将原来数组里的值返回给新的定义的数组，这个方法是直接将整个数组当成了一个值返回给了newArr，这样也可以达到切断引用的作用。
>
>    ![image-20231001094747640](JS笔记.assets/image-20231001094747640.png)

## 函数

### arguments实参列表类数组集合

> JavaScript 函数有一个名为 arguments 对象的内置对象。
>
> arguments 对象包含函数调用时使用的参数数组。
>
> + 是函数的实参列表，集合，函数在调用的时候传入的实参，形成的arguments
> + arguments为类数组，长得像数组，有length，可遍历，但是不能用数组的方法
>
> arguments的值是可以进行更改的
>
> ![image-20231002111029981](JS笔记.assets/image-20231002111029981.png)
>
> 上述代码的输出值为102，实参的值也可以在函数内部进行更改，同样arguments的值也可以进行更改。

### IIFE自调用函数

> 一般函数需要函数名调用或者是变量名调用才能执行，而自调用函数相当于把函数转换为语句的形式让其自己执行，不需要调用就可以执行。推荐以下两种方式的写法：![image-20231002154504194](JS笔记.assets/image-20231002154504194.png)

### 函数注释

> ![image-20231002160805444](JS笔记.assets/image-20231002160805444.png)

### 作用域

> ![image-20231002164924835](JS笔记.assets/image-20231002164924835.png)
>
> 一个简单的例子如下：
>
> ```
> function fn() {
> 	var x = y = 10;
> }
> fn();
> console.log(y);  //控制台打印输出10
> console.log(x);  //x为undefined
> ```
>
> 解析：
>
> ![image-20231003101822476](JS笔记.assets/image-20231003101822476.png)
>
> 
>
> ```
>   var x = 10;
>   function fn() {
>     console.log(x);   //打印x，x没有在当前域找到声明var，向上层寻找从而确定是全局变量，然后打印全局变量x的值
>     x = 20;   //修改全局变量的值为20
>   }
>   fn();   //该函数调用结果为10
>   （如果将函数里的x = 20改为var x = 20，则该函数运行结果为undefined，因为如果是var x，则说明在函数中即当前作用域有x，变量提升，此时尚未赋值）
> ```
>
> 

### 立即执行函数

> 匿名函数不能直接运行，得加一个括号表示前面的部分是一个整体，后面加一个括号表示调用，这整个部分也即是一个立即执行函数，一般情况下只会执行一次。![image-20230909094535808](JS笔记.assets/image-20230909094535808.png)


