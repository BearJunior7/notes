# HTML基础标签与CSS样式

## HTML基础标签

### 标签属性

> 属性 标签的附加价值和特性 可以通过设置属性值的方式 让标签的某一方面展示行为发生改变
>
> 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本 语法格式如下：

`<标签名 属性1="属性值1" 属性2="属性值2" … > 内容 </标签名>`

#### 属性的格式和书写:

> 1. 标签可以拥有多个属性 ，必须写在开始标签中 ，位于标签名后面。
> 2. 属性之间不分先后顺序 ，标签名与属性、属性与属性之间均以空格分开。
> 3. 任何标签的属性都有默认值，省略该属性则取默认值。
> 4. 属性采用键值对的书写方式 key="value"
>    例子:
>
> `<a href="https://www.baidu.com/"></a>`
>
> 属性名称 href
>
>  属性值 "https://www.baidu.com/" 

### base标签

> 标签为页面上的所有链接规定默认地址或默认目标。
>
> base 写到   之间
>
> 把所有的连接 都默认添加 target="_blank"

### 特殊字符(转义符号)

> 让浏览器能够理解 ***\*非排版意图\**** 的格式和行为 HTML容许使用特殊字符进行转义行为
>
> [转义符对照表](https://tool.oschina.net/commons?type=2)



| 特殊字符 | 描述     | 转义符        |
| :------- | -------- | ------------- |
|          | 空格     | `&nbsp;`      |
| <        | 小于号   | ` &lt`        |
| \>       | 大于号   | ` &gt;`       |
| &        | 和号     | ` &amp;`      |
| ￥       | 人民币   | ` 	&yen; ` |
| ©        | 版权     | ` &copy;`     |
| ®        | 注册商标 | ` &reg;`      |

### 注释标签

> HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显 示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：

` <!-- 注释语句 -->  ctrl + /   或者 ctrl +shift + /`

> 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看 源代码时就可以看到。

###  文本格式化标签(小标签)

> 在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。



| 标签        | 描述                     |
| :---------- | ------------------------ |
| b 和 string | 文字以 **粗体** 方式显示 |
| i 和 em     | 文字以 斜体 方式展示     |
| s 和 del    | 文字以 删除线 方式展示   |
| u 和 ins    | 文字以 下划线 方式展示   |

> **b i s u** **只有表现形式** **strong em del ins** **的语义更强烈**

### 图片标签

> 单词缩写 image(图像)

> HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详
>
> 细介绍图像标签
>
> 以及和他相关的属性。其基本语法格式如下：

> 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。

### 属性

| 属性   | 属性值           | 描述                   |
| :----- | ---------------- | ---------------------- |
| src    | URL              | 图像路径               |
| alt    | 文本             | 图片的描述和替代文本   |
| width  | 数值(默认单位px) | 图片的宽度             |
| height | 数值(默认单位px) | 图片的高度             |
| title  | 文本             | 鼠标悬停显示的内容     |
| border | 数字(非常规)     | 设置图片默认边框的宽度 |

### 列表系列

> 一系列内容以横列队列 的形势中展现 列表最大的特点就是 整齐 、整洁、 有序.

#### 无序列表 ul>li

> 无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：

```
<ul>
<li>列表项1</li>
<li>列表项2</li>
<li>列表项3</li>
......
</ul>
```

> 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。

```
1. <ul></ul>中只能嵌套<li></li>，直接在<ul></ul>标签中输入其他标签或者文字的做法是不被允许的。
2. <li>与</li>之间相当于一个容器，可以容纳所有元素。
3. 无序列表会带有自己样式属性 可以通过CSS修改默认样式
```

#### 有序列表 ol>li

> 有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：

```
<ol>
<li>列表项1</li>
<li>列表项2</li>
<li>列表项3</li>
......
</ol>
```

> 和UL无序列表的表现性质很相似 不同的是 索引器 是有序的数字 用到的地方比较少

#### 自定义列表 dl>dt+dd

> 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：

```
<dl>
<dt>名词1</dt>
<dd>名词1解释1</dd>
<dd>名词1解释2</dd>
...
<dt>名词2</dt>
<dd>名词2解释1</dd>
<dd>名词2解释2</dd>
...
</dl>
```

### div标签(盒子)

> div标签是没有语义的 是DIV+CSS时代的核心标签 单纯进行内容标签的容纳
>
> div是 division 的缩写 意思是 分割 分区 我们可以利用DIV来给页面划分不同的区域 呈现不同内容

**语法**

```
<div>
<p><span>some text.</span>some other text.</p>
</div>
```

#### span标签

> span标签是没有语义的 通常来组合行内元素，以便通过样式来格式化它们。
>
> span 没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。

**语法:**

` <p><span>some text.</span>some other text.</p>`



## **CSS (Cascading Style Sheets)** **层叠样式表**

> CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。
>
> CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。
>
> **CSS可以帮助调整排版布局的展现 美化标签和内容 提高版面的信息密度 加强信息的冲击力和直观性**

### **行内式（内联样式）**

>  内联样式，又有人称行内样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下：

` <标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"> 内容 </标签名>`

> 语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。

### **内部样式表**

内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：

```
<head>
<style type="text/CSS">
选择器 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3;}
</style>
</head>
```

语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。

`type="text/CSS" 在html5`中可以省略， 写上也比较符合规范， 所以这个地方可以写也可以省略。

### **外部样式表（外链式）**

链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下：

```
<head>
<link href="CSS文件的路径" rel="stylesheet" />
</head>
```

注意： link 是个单标签哦!!!

该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下：

```
href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。
type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。
rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。
```

### **三种样式表总结（位置）**

| **样式表** | **优点**             | **缺点**                 | **使用情况**   | **控制范围**       |
| :--------- | -------------------- | ------------------------ | -------------- | ------------------ |
| 行内样式表 | 书写方便，权重高     | 没有实现样式和结构相分离 | 较少           | 控制一个标签（少） |
| 内部样式表 | 部分结构和样式相分离 | 没有彻底分离             | 较多           | 控制一个页面（中） |
| 外部样式表 | 完全实现结构和样式相 | 需要引入                 | 最多，强烈推荐 | 控制整个站点（多） |

### **CSS****样式规则**

使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，具体格式如下： 

```
在上面的样式规则中:
1. 选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。
2. 属性和属性值以“键值对”的形式出现。
3. 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。
4. 属性和属性值之间用英文“:”连接。
5. 多个“键值对”之间用英文“;”进行区分。
可以用段落 和 表格的对齐的演示。
```



### **选择器（重点）**

要想将CSS样式应用于特定的HTML元素，首先需要找到该目标元素。在CSS中，执行这一任务的样式规则部分被称为选择器（选择符）

> 我们如何把羊群分类 黑 白 灰
>
> 选择器干啥的？ 选择标签用的
>
> 这就用到基础选择器组：

##**CSS****基础选择器**

### 标签选择器（元素选择器)

标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下：

```
标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 或者
元素名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
```

标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。

标签选择器 可以把某一类标签全部选择出来 div span

### 类选择器

类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：

```
.类名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 

标签调用的时候用 class=“类名” 即可。
```

类选择器最大的优势是可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签

+ **命名规范**

```
1. 命名需要是具备语义性的单词，不能用 数字 拼音 符号
正确示范 ： wrap description title content
错误示范 : aaaa a1 $we 4tdds
2. 命名需要多个单词连接的情况下, 标记语言中可以使用 _ - 进行连接 不能直接单词拼接 或者驼峰命名 注意: 书写风格必须
统一 不容许出现 _ -一起使用的情况 推荐使用 -
正确示范 : header-nav content-left slide-bar
错误示范 : headernav slideBar ContentLeft
3. 命名需要进行适当的缩写, 单词连接层级不要超过4层
正确示范 : head-tit_ico
错误示范 : header-title-left-logo-icon
```

### **多类名选择器**

我们可以给标签指定多个类名，从而达到更多的选择目的。

注意：

```
1. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。
2. 各个类名中间用空格隔开。
```

多类名选择器在后期布局比较复杂的情况下，还是较多使用的。

> `<div class="melon green fz20">西瓜</div>`
>
> `<div class="melon cyan">冬瓜</div>`
>
> `<div class="melon yellow">南瓜</div>`

### **id****选择器**

id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下：

```
#id名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
```

该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。

用法基本和类选择器相同。

### **id****选择器和类选择器区别**

W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。

类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜

id选择器 好比人的身份证号码， 全中国是唯一的， 不得重复。 只能使用一次。

**id选择器和类选择器最大的不同在于 使用次数上。**

### **通配符选择器**

> 通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下：

```
* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }
```

例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。

```
* {
margin: 0; /* 定义外边距*/
padding: 0; /* 定义内边距*/
}
```

> 通配符选择器一般用于DEMO页面的统一清除默认margin 和 padding 其他地方应用很少

### **CSS****外观属性**

#### **color:****文本颜色**

color属性用于定义文本的颜色，其取值方式有如下3种：

1.预定义的颜色值，如red，green，blue等。

2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。

3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。

需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。

#### **line-height:****行间距**

line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的

属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px

一般情况下，行距比字号大7 8像素左右就可以了。

#### **text-align:****水平对齐方式**

text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下：

left：左对齐（默认值）

right：右对齐

center：居中对齐

#### **text-indent:****首行缩进**

text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。

1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度

**text-decoration** **文本的装饰**

text-decoration 通常我们用于给链接修改装饰效果

![image-20230930124726072](HTML与CSS.assets/image-20230930124726072.png)



### **块级元素****(block-level)**

每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建

+ 常见的块元素有<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>等，其中<div>标签是最典型的块元素。

> DIV 是最常用的块元素 规规矩矩 方方正正 很好管理 被人们称为 "可靠的同志" 但是体格庞大 独占一行

块级元素的特点：

（1）总是从新行开始

（2）高度，行高、外边距以及内边距都可以控制

（3）宽度默认是容器的100%

（4）可以容纳内联元素和其他块元素

### **行内元素****(inline-level)**

行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。

```
常见的行内元素有<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>等，其中<span>标签最典型的行内元素。

行内元素是通常集体出没 能够排成行伍 训练有素 整齐划一
```

行内元素的特点：

（1）和相邻行内元素在一行上。

（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。

（3）默认宽度就是它本身内容的宽度。

（4）行内元素只能容纳文本或则其他行内元素。（a特殊）

**PS**:

1.  只有 文字才 能组成段落 因此 p 里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。

2.  链接里面不能再放链接

### **块级元素和行内元素区别**

```
块级元素的特点：
（1）总是从新行开始
（2）高度，行高、外边距以及内边距都可以控制。
（3）宽度默认是容器的100%
（4）可以容纳内联元素和其他块元素。
```

```
行内元素的特点：
（1）和相邻行内元素在一行上。
（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。
（3）默认宽度就是它本身内容的宽度。
（4）行内元素只能容纳文本或则其他行内元素。
```

###  **行内块元素（****inline-block）**

```
行内块元素的特点： 同时具备行内元素和块元素的特性
（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。
（2）默认宽度就是它本身内容的宽度。
（3）高度, 宽度，行高、外边距以及内边距都可以设置。
```

> **注意**: 在行内元素中有几个特殊的标签(如img)这些标签虽然可以设置宽度高度
>
> 但是在现代浏览器内特性默认展示模式为 行内(inline) 元素

**标签显示模式转换** **display**

块转行内：display:inline;

行内转块：display:block;

块、行内元素转换为行内块： display: inline-block;

### **盒子模型（****CSS****重点）**

其实，CSS就三个大模块： 盒子模型 、 浮动 、 定位，其余的都是细节。

所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。

> 所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素在网页布局汇总所占的位置大小。因此，**每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。**

**width** **元素宽度**

width用来给元素设置宽度 注意: 只有块(block)元素或者行内块(inline-block)元素才能够设置

**height** **元素宽度**

height用来给元素设置高度 注意: 只有块(block)元素或者行内块(inline-block)元素才能够设置

**盒子边框（****border****）**

边框就是那层皮。 橘子皮。。柚子皮。。橙子皮。。。

语法:

```
border : border-width || border-style || border-color
```

边框属性—设置边框样式（border-style）

边框样式用于定义页面中边框的风格，常用属性值如下：

```
none：没有边框即忽略所有边框的宽度（默认值）
solid：边框为单实线(最为常用的)
dashed：边框为虚线
dotted：边框为点线
double：边框为双实线
```

**内边距（****padding****）**

padding属性用于设置内边距。 是指 边框与内容之间的距离。

padding-top:上内边距

padding-right:右内边距

padding-bottom:下内边距

padding-left:左内边距

注意： 后面跟几个数值表示的意思是不一样的

**外边距（****margin****）**

margin属性用于设置外边距。 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。

margin-top:上外边距

margin-right:右外边距

margin-bottom:下外边距

margin-left:上外边距

margin:上外边距 右外边距 下外边距 左外边

取值顺序跟内边距相同

**外边距实现盒子居中**

可以让一个盒子实现水平居中，需要满足一下两个条件：

1. 必须是块级元素。 

2. 盒子必须指定了宽度（width）

然后就给**左右的外边距都设置为****auto**，就可使块级元素水平居中。

实际工作中常用这种方式进行网页布局，示例代码如下：

```
.header{ width:960px; margin:0 auto;}
```

**文字盒子居中图片和背景区别**

1. 文字水平居中是 text-align: center

2. 盒子水平居中 左右margin 改为 auto

```
text-align: center; /* 文字居中水平 */
margin: 10px auto; /* 盒子水平居中 左右margin 改为 auto 就阔以了 */
```

3. 插入图片 我们用的最多 比如产品展示类

4. 背景图片我们一般用于小图标背景 或者 超大背景图片

```
section img {
	width: 200px;/* 插入图片更改大小 width 和 height */
	height: 210px;
	margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */
	margin-left: 50px; /* 插入当图片也是一个盒子 */
}
aside {
	width: 400px;
    height: 400px;
    border: 1px solid purple;
    background: #fff url(images/sun.jpg) no-repeat;
    background-size: 200px 210px; /* 背景图片更改大小只能用 background-size */
    background-position: 30px 50px; /* 背景图片更该位置 我用 background-position */
}
```

**清除元素的默认内外边距**

为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距：

```
* {
padding:0; /* 清除内边距 */
margin:0; /* 清除外边距 */
}
```

注意： 行内元素是只有左右外边距的，是没有上下外边距的。 内边距，在ie6等低版本浏览器也会有问题。

我们尽量不要给行内元素指定上下的内外边距就好了。

**外边距合并**

使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。

**相邻块元素垂直外边距的合并**

当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。

![image-20230930125854487](HTML与CSS.assets/image-20230930125854487.png)

**嵌套块元素垂直外边距的合并**

对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并

![image-20230930125931597](HTML与CSS.assets/image-20230930125931597.png)

解决方案：

1. 可以为父元素定义1像素的上边框或上内边距。

2. 可以为父元素添加overflow:hidden。

**content****宽度和高度**

使用宽度属性width和高度属性height可以对盒子的大小进行控制。

width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。

大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是:

```
/*外盒尺寸计算（元素空间尺寸）*/
Element空间高度 = content height + padding + border + margin
Element 空间宽度 = content width + padding + border + margin
/*内盒尺寸计算（元素实际大小）*/
Element Height = content height + padding + border （Height为内容高度）
Element Width = content width + padding + border （Width为内容宽度）
```

注意：

1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。

2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。

3、**如果一个盒子则会和父亲一样宽 占满父亲的宽度， 如果此盒子没有给定宽度 则****padding** **不会影响本盒子大****小**。

**盒子模型布局稳定性**

 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。

原因：

1. margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。

2. padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。

3. width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做

### 怪异盒子**模型**

> 怪异盒模型是IE盒子模型 我们可以通过 css 样式 box-sizing来进行切换

```
select {
box-sizing: border-box; /* 怪异盒子模型 */
box-sizing: content-box; /* 标准盒子模型 */
}
```

> 怪异盒子模型的 宽度 高度计算 和标准盒子模型计算方式不同 怪异盒子模型的 content内容宽度会把
>
> padding和border算入其中 是由外而内的计算宽度

### **两种盒子模型区别**

> 主要区别在于盒子的整体宽度高度计算方式不同

1. 用途：正常盒模型主要用于PC端，怪异盒模型主要用于手机端。

2. 原理：正常盒模型的大小是由内到外的，由内部决定外部的大小；而怪异盒模型是由外而内的。

3. 可以同时设置 box-sizing属性来使用这一特性，是其改变border宽度也不影响其他元素；

4. box-sizing:简单理解就是盒子大小基于什么计算的;

**盒子模型相关知识点补充说明**

**高度样式设置****auto**

> 图片标签 给设置具体宽度后 可以给高度设置为 auto(自动) 值让其实现等比例自动计算

**同行宽度问题**

> 一行内如果多个元素 站位宽度(margin+border+padding+width) 相加大于 容器宽度 无法完整放入的元素会被挤下一行展示

**内外边距问题**

> 1. 外边距垂直方向会合并 选最大值 , 水平方向会进行叠加
> 2. 外边距如果父容器没有边界(硬性边界,边框,内边距) 就会产生穿透效果 子元素的外边距会穿透父元素生效
> 3. 内外边距都只能设置为整数 不要设置带小数的 边距 长宽

**行高与高度**

> 当行高与高度相等的时候 文本垂直居中



### **CSS** **背景****(background)**

CSS 可以添加背景颜色和背景图片，以及来进行图片设置

| **background-color**                                         | **背景颜色**     |
| ------------------------------------------------------------ | ---------------- |
| background-image                                             | 背景图片地址     |
| background-repeat                                            | 是否平铺         |
| background-position                                          | 背景位置         |
| background-attachment                                        | 背景固定还是滚动 |
| 背景的合写（复合属性）                                       |                  |
| background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置/背景尺寸 |                  |
| background-size                                              | 背景尺寸         |

**背景透明(CSS3)**

CSS3支持背景半透明的写法语法格式是:

````
background: rgba(0,0,0,.3);
````

最后一个参数是alpha 透明度 取值范围 0~1之间

注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。

### **CSS复合选择器**

复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。

**交集选择器**

> 交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special
>
> 交集选择器 是 并且的意思。 即...又...的意思

```
比如： p.one 选择的是： 类名为 .one 的 段落标签。
```

**并集选择器**

> 并集选择器（CSS选择器分组）是各个选择器通过**逗号**连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。

> 并集选择器 和 的意思， 就是说，只要逗号隔开的，所有选择器都会执行后面样式。

```
比如 .one, p , #test {color: #F00;} 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。
```

**后代选择器**

> 后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。

**子代选择器**

> 子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 > 进行连接，注意，符号左右两侧各保留一个空格。
>
> 这里的子 指的是 亲儿子 不包含孙子 重孙子之类。

### **CSS** **三大特性**

层叠 继承 优先级 是我们学习CSS 必须掌握的三个特性。

**CS层叠性**

所谓层叠性是指多种CSS样式的叠加。

是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉

比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。 就近原则

一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。

1. 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。

2. 样式不冲突，不会层叠

**CSS继承性**

所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。

简单的理解就是： 子承父业。

注意：

恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性）

**CSS优先级**

定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。

在考虑权重时，初学者还需要注意一些特殊的情况，具体如下：

> 继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。
>
> 行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。
>
> 权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。
>
> CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。

**CSS权重特殊性（Specificity）**

关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下：

specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。

![image-20230930131801367](HTML与CSS.assets/image-20230930131801367.png)

权重是可以叠加的

比如的例子：

```
div ul li ------> 0,0,0,3
.nav ul li ------> 0,0,1,2
a:hover -----—> 0,0,1,1
.nav a ------> 0,0,1,1
#nav p -----> 0,1,0,1
```

注意：

1.数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选

择器的情况。

1. 继承的 权重是 0

总结优先级：

+ 1. 使用了 !important声明的规则。

+ 2. 内嵌在 HTML 元素的 style属性里面的声明。
  3. 使用了 ID 选择器的规则。
  4. 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。
  5. 使用了元素选择器的规则。
  6. 只包含一个通用选择器的规则。
  7.  同一类选择器则遵循就近原则。

**vertical-align** **垂直对齐模式**

```
vertical-align : baseline |top |middle |bottom |sub
```

设置或检索对象内容的垂直对其方式。

vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， **通常用来控制图片/表单与文字的对齐**。

![image-20230930132128419](HTML与CSS.assets/image-20230930132128419.png)

**图片、表单和文字对齐**

所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。

**去除图片底侧空白缝隙**

有个很重要特性： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。这样会造成一个问题，就是图片底侧会有一个空白缝隙。

解决的方法就是：

1. 给img vertical-align:middle | top等等。 让图片不要和基线对齐。
2.  给img 添加 display：block; 转换为块级元素就不会存在问题了。

**溢出的文字隐藏**

```
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap
```

**white-space:****自动换行**

![image-20230930132328184](HTML与CSS.assets/image-20230930132328184.png)

**text-overflow** **文字溢出

text-overflow : clip | ellipsis

设置或检索是否使用一个省略标记（...）标示对象内文本的溢出

clip : 不显示省略标记（...），而是简单的裁切

ellipsis : 当对象内文本溢出时显示省略标记（...）

注意一定要首先强制一行内显示，再次和overflow属性 搭配使用

**多行文本超出隐藏**

```
display: -webkit-box; /* -webkit-inline-box; 行内元素*/
-webkit-box-orient: vertical;
-webkit-line-clamp: 3; /* 控制在第几行的结尾进行显示 ...*/
overflow: hidden;
/*高度 宽度必须规定好 不然...之后一行 也会展示出来*/
```

### **伪类选择器**

 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。

伪类 .one

伪类 :link

**链接伪类选择器**

+ :link /* 未访问的链接 */

+ :visited /* 已访问的链接 */

+ :hover /* 鼠标移动到链接上 */

+ :active /* 选定的链接 */

**注意**写的时候，他们的顺序尽量不要颠倒 按照 **lvha** 的顺序。 love hate 爱上了讨厌 记忆法 或者 lv 包

包 非常 hao

```
a { /* a是标签选择器 所有的链接 */
font-weight: 700;
font-size: 16px;
color: gray;
}
a:hover { /* :hover 是链接伪类选择器 鼠标经过 */
color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */
}
```

### **结构****(****位置****)****伪类选择器（****CSS3)**

+ :first-child :选取属于其父元素的首个子元素的指定选择器

+ :last-child :选取属于其父元素的最后一个子元素的指定选择器

+ :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型

+ :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。

​	n 可以是数字、关键词或公式

+ nth-of-type(n): 匹配同类型中的第n个同级兄弟元素 n可以是一个数字，一个关键字，或者一个公式

+ :first-of-type: 匹配同类型中的第一个同级兄弟元素 没有() 参数

+ :last-of-type: 匹配同类型中的最后一个同级兄弟元素 没有() 参数

+ :only-of-type 匹配同类型中的唯一一个指定类型元素 没有() 参数

+ :not(s) 匹配每个元素是不是指定的元素/选择器 s为选择器 selector的缩写

```
li:first-child { /* 选择第一个孩子 */
color: pink;
}
li:last-child { /* 最后一个孩子 */
color: purple;
}
li:nth-child(4) { /* 选择第4个孩子 n 代表 第几个的意思 */
color: skyblue;
}
p:nth-of-type(3) { /* 选择第3个同类别的兄弟元素 n 代表 第几个的意思 */
background-color: #f00;
}
p:first-of-type { /* 选择每个p元素是其父级的第一个p元素*/
color: skyblue;
}
p:last-of-type { /* 选择每个p元素是其父级的最后一个p元素 */
color: pink;
}
p:only-of-type { /* 选择每个p元素是其父级的唯一p元素 */
color: yellow;
}
p:not(.desc) { /* 选中除了类名为desc的其他p标签*/
color: green
}
```

### **属性选择器**

选取标签带有某些特殊属性的选择器 我们成为属性选择器 规定 值都加 引号

```
/* 获取到 拥有 该属性的元素 */
div[class^='font'] { /* class^=font 表示 font 开始位置就行了 */
color: pink;
}
div[class$='footer'] { /* class$=footer 表示 footer 结束位置就行了 */
color: skyblue;
}
div[class*='tao'] { /* class*=tao *= 表示tao 在任意位置都可以 */
color: green;
}
```

```
<div class="font12">属性选择器</div>
<div class="font12">属性选择器</div>
<div class="font24">属性选择器</div>
<div class="font24">属性选择器</div>
<div class="font24">属性选择器</div>
<div class="24font">属性选择器123</div>
<div class="sub-footer">属性选择器footer</div>
<div class="jd-footer">属性选择器footer</div>
<div class="news-tao-nav">属性选择器</div>
<div class="news-tao-header">属性选择器</div>
<div class="tao-header">属性选择器</div>
</div>
```

### **伪元素选择器（CSS3)**

1. E::first-letter文本的第一个单词或字（如中文、日文、韩文等）

2. E::first-line 文本第一行；

3. E::selection 可改变选中文本的样式；

```
/* 首字特殊样式 */
p::first-letter {
font-size: 20px;
color: hotpink;
}
/* 首行特殊样式 */
p::first-line {
color: skyblue;
}
p::selection {
/* font-size: 50px; */
color: orange;
}
```

4. E::before和E::after

在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。

```
div::befor {
content:"开始";
}
div::after {
content:"结束";
}
```

E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。

":" 与 "::" 区别在于区分伪类和伪元素 **注意****: IE9****下 不支持****::** **所以保证兼容可以写为** **:**

之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。是伪元素在html代码机构中的展现，可以看出无法伪元素的结构无法审查

**注意**

伪元素:before和:after添加的内容默认是inline元素**；这个两个伪元素的 content 属性，表示伪元素的内容,设置:before和:after时必须设置其 content 属性，否则伪元素就不起作用。

### **表单组成部分**

**表单控件：input select textarea button**

 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。

**提示信息：label**

 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。

**表单域： form**

 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。

**input控件 (最常用)**

在上面的语法中，<input> 标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，<input >标签还可以定义很多其他的属性，其常用属性如下图所示。

![image-20230930133210461](HTML与CSS.assets/image-20230930133210461.png)

## **浮动****(float)**

### **普通流****(normal flow)**

这个单词很多人翻译为 文档流 ， 字面翻译 普通流 或者标准流都可以。

前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？

CSS的定位机制有3种：普通流（标准流）、浮动和定位。

html语言当中另外一个相当重要的概念----------标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。

### **浮动****(float)**

浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。

后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了

**浮动详细内幕特性**

浮动脱离标准流，=脱标==不占位置，会影响标准流。浮动只有左右浮动。

> 1. 浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。

> 2. 一个父盒子里面的子盒子，如果需要所有子元素一行对齐显示，就需要所有子元素都进行浮动。

> 3. 元素添加浮动后，元素会变为块元素。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。

总结： 浮动 ---> 

浮动的目的就是为了让多个块级元素同一行上显示。 最核心的关键点就是 怎么排列的， 是否占有位置

> 1. 浮动 脱离文档流 的，原来还在文档流的元素，会向上移动
>
> 2. 元素浮动以后，会尽量向页面的左上或是右上漂浮，直到遇到 父元素的内边距或者其他元素的浮动元素
>
> 3. 如果浮动的元素上边是一个没有浮动的块级元素，则浮动的元素不会超过块级元素
>
> 4. 浮动的元素不会超过上边的兄弟元素
>
> 5. 浮动会更改元素的显示方式 : block

**清除浮动**

浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但

是不能说浮动不好 。

由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。

准确地说，并不是清除浮动，而是**清除浮动后造成的影响

**清除浮动本质**

清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。

**清除浮动的方法**

其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。

在CSS中，clear属性用于清除浮动，其基本语法格式如下：

```
选择器{clear:属性值;} clear 清除
```

![image-20230930133643358](HTML与CSS.assets/image-20230930133643358.png)

**额外标签法**

```
是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <div style=”clear:both”></div>，或则其他标签br等亦可。
```

优点： 通俗易懂，书写方便

缺点： 添加许多无意义的标签，结构化较差。

**父级添加****overflow****属性方法**

可以通过触发BFC的方式，可以实现清除浮动效果

> 可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。

优点： 代码简洁

缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。

**内容溢出时处理** **overflow**

> overflow 属性规定当内容溢出元素框时发生的事情。

**使用after伪元素清除浮动**

:after方式为空元素的升级版，好处是不用单独加标签了

使用方法：

```
.clearfix:after { content: ""; display: block; height: 0; clear: both; visibility: hidden; }
.clearfix {*zoom: 1;} /* IE6、7 专有 */
```

优点： 符合闭合浮动思想 结构语义化正确

缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout

> haslayout是IE7-浏览器的特有属性。hasLayout是一种只读属性，有两种状态：true或false。当其为true时，代表该元素有自己的布局，否则代表该元素的布局继承于父元素。）

代表网站： 百度、淘宝网、网易等

**使用before和after双伪元素清除浮动**

使用方法：

```
clearfix:before,.clearfix:after {
content:"";
display:table; 
}
.clearfix:after {
clear:both;
}
.clearfix {
*zoom:1;
}
```

优点： 代码更简洁

缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。

代表网站： 小米、腾讯等

**进阶安全版**

使用方法：

```
.clearfix{
zoom:1;
}
.clearfix:after,.clearfix:before{
content:"";
display:table;
}
.clearfix:after{
clear:both;
visibility:hidden;
font-size:0;
height:0;
}
```

## **定位****(position)**

如果，说浮动， 关键在一个 “浮” 字上面， 那么 我们的定位，关键在于一个 “位” 上。

定位原理上可以帮助你快速精准 脱离文档流束缚的情况下将元素放在你想放置的位置。就跟精确制导定位系统一样，输入坐标就可以轻松搞定。

**元素的定位属性**

元素的定位属性主要包括定位模式和边偏移两部分。

1) 定位模式(定位的分类)

​	在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下：

​	选择器{position:属性值;}

​	position属性的常用值static relative absolute fixed

2.  边偏移

   ` top bottom left right `

## **css3** **新增样式**

### **border-radius** **圆角属性**

> 这个属性允许你为元素添加圆角边框

```
border-radius: 1-4 length|% / 1-4 length|%;
/* xy合并参数写法 */
border-radius: 10px 20px 30px 40px;
border-radius: top-left top-right bottom-right bottom-left
/* 全参数写法 */
border-radius: 10px 20px 30px 40px / 40px 30px 20px 10px;
border-radius: top-left-x top-right-x bottom-right-x bottom-left-x / top-left-y top-right-y bottom-right-y bottom-left-y
```

复合与单例写法对比

```
border-radius:2em;
/*对应单例写法为*/
border-top-left-radius:2em;
border-top-right-radius:2em;
border-bottom-right-radius:2em;
border-bottom-left-radius:2em;
```

```
border-radius: 2em 1em 4em / 0.5em 3em;
/*对应单例写法为*/
border-top-left-radius: 2em 0.5em;
border-top-right-radius: 1em 3em;
border-bottom-right-radius: 4em 0.5em;
border-bottom-left-radius: 1em 3em;
```

每个半径的四个值的顺序是：左上角，右上角，右下角，左下角。如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的。

> **1-4个值所对应**
>
> **四个值:** 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。
>
> **三个值:** 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角
>
> **两个值**: 第一个值为左上角与右下角，第二个值为右上角与左下角
>
> **一个值: **四个圆角值相同

x 方向 % 对应容器宽度

y方向 % 对应容器高度

### **border-image** **边框图片**

> 这个属性允许你为元素添加图片作为边框

语法:

```
border-image: source slice width outset repeat|initial|inherit;
border-image: url(border.png) 30 round;
```

### **border-shadow** **盒子阴影**

>  这个属性允许你为盒子添加阴影效果

语法：

``` 
box-shadow: h-shadow v-shadow blur spread color inset;
box-shadow: x偏移量 y偏移量 模糊半径 扩展半径 阴影颜色 阴影模式(内/外)
box-shadow: 10px 10px 20px 25px #ccc inset;
```

> boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4
>
> 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。

### **CSS3** **渐变（Gradients）**

>CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。
>
>以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的时间和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。
>
>CSS3 定义了两种类型的渐变（gradients）：
>
>**线性渐变（Linear Gradients）-向下/向上/向左/向右/对角方向**
>
>**径向渐变（Radial Gradients）- 由它们的中心定义**

语法：

```
background-image: linear-gradient(direction, color-stop1, color-stop2, ...);
background-image: radial-gradient(shape size at position, start-color, ..., last-color);
```

### **CSS3 transform 2D变幻**

**注意** transform无法作用于 行内元素

容许元素在2D平面上进行变幻 包括 平移(translate) 旋转(rotate) 缩放(scale) 倾斜(skew)

语法：

```
transform: translate(20px,30px) rotate(30deg) scale(3,4) skew(20deg,30deg);
transform-origin: x-axis y-axis z-axis;
```

**translate** **平移**

>  translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。

```
transform: translate(50px,100px);
```

**rotate** **旋转**

>  rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。

```
transform: rotate(30deg);
```

**scale** **缩放**

>  scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数

```
transform: scale(2,3);
```

**skew** **倾斜**

> 包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。

```
transform: skew(30deg,20deg);
```

### **CSS3 transition** **过渡**

> CSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript。

语法：

```
transition: property duration timing-function delay;
property 过渡的属性名称 width left 等数值型或 color颜色
duration 过渡需要的时间 s ms
timing-function 过渡速度曲线
delay 延时时长 m ms
```

### **CSS3** **帧动画** **amimation @keyframes**

> 在 CSS3 出现之前，动画都是通过 JavaScript 动态的改变元素的样式属性来完成了，这种方式虽然能够实现动画，但是在性能上存在一些问题。CSS3 的出现，让动画变得更加容易，性能也更加好。
>
> animation 比较类似于 flash 中的**逐帧动画**，逐帧动画就像电影的播放一样，表现非常细腻并且有非常大的灵活性。然而 transition 只是指定了开始和结束态，整个动画的过程也是由特定的函数控制。这种逐帧动画是由**关键帧**组成，很多个关键帧连续的播放就组成了动画，在 CSS3 中是由属性keyframes 来完成逐帧动画的

**@keyframes** **关键帧**

>  通过@keyframes设置自定义名称的动画关键帧 在动画关键节点设置数值

+ animationName：动画名称，开发人员自己命名；

+ percentage：为百分比值，可以添加多个百分比值；

+ properties：样式属性名称，例如： color 、 left 、 width 等等。

**animation** **播放动画**

 		animation-name

​	它是用来设置动画的名称，可以同时赋值多个动画名称，用 , 隔开：

​		animation-duration

​	它是用来设置动画的持续时间，单位为 s ，默认值为 0 ：

​		animation-timing-function

​	和 transition-timing-function 类似：

​		animation-delay

​	它是来设置动画的开始时间，单位是 s 或者 ms ，默认值为0：

​		animation-iteration-count

​	它是来设置动画循环的次数，默认为 1 ， infinite 为无限次数的循环：

​		animation-direction

​	它是来设置动画播放的方向，默认值为 normal 表示向前播放， alternate 代表动画播放在第偶数次向前播放，第奇数次向反方向播放：

​		animation-play-state

​	它主要是来控制动画的播放状态： running 代表播放，而 paused 代表停止播放， running 为默认值：

​	PS: 

​	animation-play-state 无法通过animation复合书写 只能单例设置 与 transform-origin 一样

**animation**复合写法

> 它是 animation-name 、 animation-duration 、 animation-timing-function 、 animation-delay 、 animation-iteration-count 、 animation-direction 的简写：

## **CSS3** **弹性布局** **flex**

> 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，**垂直居中**就不容易实现。
>
> 2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能，时至今日 flex已经成为主流布局方式 ， 尤其在移动端 小程序等方面表现出色。

> Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。
>
> 任何一个容器都可以指定为 Flex 布局, 行内元素也可以使用 Flex 布局。
>
> 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。

**容器属性**

一共有6种css属性用于调整flex 布局

> flex-direction  	 属性决定主轴的方向（即项目的排列方向）默认横向 row
>
> flex-wrap    	属性定义，如果一条轴线排不下，如何换行
>
> flex-flow		属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap 
>
> justify-content		属性定义了项目在主轴上的对齐方式
>
> align-items		属性定义项目在交叉轴上如何对齐
>
> align-content		属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

### **优雅降级和渐进增强**

> 渐进增强 progressive enhancement：
>
> 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
>
> 农村包围城市的味道
>
> 一个简单的例子，例如先完成了页面的基本布局，没有任何特效，那么加个小动画，加个文字阴影等，就是**渐进增强**了

> **优雅降级** **graceful degradation：**
>
> 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
>
> 类似蹦极，由高处往低处下落
>
> 让一部分人先富起来带动另一部分人富起来的感觉

> 区别：渐进增强是向上兼容，优雅降级是向下兼容。

### **3D变换transform3D**

> 浏览器中我们除了可以实现 x y两轴的2D变换 也可以开启3D效果 3D效果经常用于一些复杂的绚丽效果展示可以用来构建基础的3D模型空间
>
> 3D变形涉及的属性主要是transform-origin、transform、transform-style、perspective、perspective-origin、backface-visibility

### **CSS content** **计数器**

> CSS 计数器通过一个变量来设置，根据规则递增变量

使用计数器自动编号

CSS 计数器根据规则来递增变量。

CSS 计数器使用到以下几个属性：

​		counter-reset - 创建或者重置计数器

​		counter-increment - 递增变量

​		content - 插入生成的内容

​		counter() 或 counters() 函数 - 将计数器的值添加到元素

要使用 CSS 计数器，得先用 counter-reset 创建

### **BFC**

> BFC(Block Formatting Contexts) 直译为"块级格式化上下文"。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。

> GFC(GridLayout Formatting Contexts)直译为"网格布局格式化上下文"，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器 (grid container) 上定义网格定义行(griddefinition rows) 和网格定义列 (grid definition columns) 属性各在网格项目 (grid item) 上定义网格行(gridrow) 和网格列 (grid columns)为每一个网格项目(grid item)定义位置和空间。

**BFC形成条件**

+ 根元素

+ float 属性不为 none

+ position 为 absolute 或 fixed

+ display 为inline-block, table-cell, table-caption , flex， inline-flex

+ overflow 不为 visible ( hidden auto scroll )。

> BlochFormatting Context提供了一个环境HTML元素在这个环境中按照一定规则进行布局

>  形成一个完全独立的大箱子 箱子中的子元素与外部元素隔绝开来 不管内部元素怎么搞 都不会影响到外部, 内部形成一个独立的文档流。

**BFC元素所具有的特性**

BFC布局规则特性：

1.在BFC中，盒子从顶端开始垂直地一个接一个地排列.

2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠

3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。

1. BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。

2. 计算BFC的高度时，自然也会检测浮动的盒子高度。

它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。

**BFC的主要用途**

清除浮动影响

处理外边距穿透&合并

实现两栏|三栏自适应布局

**iframe 内联框架** 

> 可以将另一个网页通过iframe框架引入到当前页面
